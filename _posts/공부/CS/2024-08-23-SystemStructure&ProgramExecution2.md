---
layout: post
title: "시스템 구조 및 프로그램 실행2"
date: 2024-08-23
categories:
  - study
  - CS
description: >
  이화여대 '반효경'교수님의 Operating Systems강의 중, 'System Structure & Program Execution 2'강의를 수강하고 학습합니다.
---

<img src='/assets/img/공부/CS/hardware.png' alt='하드웨어 분류'/>

하드웨어 분류

<img src='/assets/img/공부/CS/computerSystem.png' alt='하드웨어를 조작하는 소프트웨어' />

하드웨어를 조작하는 소프트웨어

# 동기식 입출력과 비동기식 입출력

<img src='/assets/img/공부/CS/sync.png' alt='동기식 & 비동기식 입출력 비교' />

## 동기식 입출력 (Synchronous I/O)

I/O 요청 후, 작업이 모두 완료된 후에야 제어가 사용자 프로그램에 넘어갑니다.

- 구현 방법 첫번째
  - I/O가 끝날 때까지 CPU를 낭비시킨다
  - 매시점 하나의 I/O만 일어날 수 있다
- 구현 방법 두번째
  - I/O가 완료될 때까지 해당 프로그램에게서 CPU를 빼앗는다
  - I/O 처리를 기다리는 줄에 그 프로그램을 줄세운다
  - 다른 프로그램에게 CPU를 준다

<aside>
⛔ 구현 방법 두번째 주의사항!! ⇒ 동기식 I/O에서 프로그램이 I/O 요청을 보낸 후, 그 요청이 완료될 때까지 기다리는 것은 맞습니다. 여기서 두번째 구현 방법에서 말하는 ‘프로그램에서 CPU를 뺴앗는다’라는 것은, I/O요청을 보낸 프로그램이 **I/O작업이 끝날 때까지 실제로 실행되지 않고 대기상태**에 들어간다는 의미입니다. 이 대기 상태에서는 프로그램이 CPU를 사용하지 않기 때문에, 운영체제는 다른 프로그램에게 CPU를 할당할 수 있습니다.

</aside>

### 비동기식 입출력 (Asynchronous I/O)

I/O가 시작된 후 입출력 작업이 끝나기를 기다리지 않고, 제어가 사용자 프로그램에게 즉시 넘어갑니다.

<aside>
💡 동기식, 비동기식 두 경우 모두 I/O의 완료는 I/O device Controler가 **인터럽트를 걸어서**알려줍니다.

</aside>

---

## DMA Controller

<img src='/assets/img/공부/CS/computerSystem.png' alt='DMA Controller' />

- 빠른 입출력 장치를 메모리에 가까운 속도로 처리하기 위해 사용합니다.
- CPU의 중재 없이 device controller가 device의 buffer storage의 내용을 메모리에 block단위로 직접 전송합니다.
- 바이트 단위가 아니라 **block**단위로 인터럽트를 발생시킵니다.

## 서로 다른 입출력 명령어

<img src='/assets/img/공부/CS/InstructionIO.png' alt='서로 다른 입출력 명령어' />

좌측: Special Instruction I/O (일반적인 방식) / 우측: Memory Mapped I/O

### Special Instruction I/O

**특징**: 이 방식에서는 CPU가 특정 명령어(Special Instruction)를 통해 I/O 작업을 수행합니다. 이 명령어는 I/O 포트에 직접 접근해서 데이터를 읽거나 쓸 수 있게 합니다.

**작동 방식**: CPU는 I/O 장치와 통신할 때, 특별히 지정된 명령어(예: `IN`, `OUT`)를 사용하여 I/O 포트와 데이터를 주고받습니다. I/O 포트는 메모리 주소와는 별도로 관리됩니다.

- **장점**: CPU와 I/O 장치 간의 데이터 전송을 분리된 명령어로 수행하여, 시스템이 더 효율적으로 작동할 수 있습니다.
- **단점**: I/O 명령어가 별도로 존재하기 때문에, CPU의 명령어 집합에 해당 명령어를 추가해야 하고, 코드가 복잡해질 수 있습니다.

### Memory-Mapped I/O

**특징**: 이 방식에서는 I/O 장치를 메모리의 일부처럼 취급합니다. 즉, I/O 장치의 레지스터가 메모리 주소 공간에 포함됩니다.

**작동 방식**: CPU는 I/O 장치를 메모리의 특정 위치로 간주하고, 메모리 접근 명령어(예: `LOAD`, `STORE`)를 사용하여 I/O 장치와 통신합니다. I/O 장치의 레지스터가 메모리 주소 공간 내의 특정 주소에 매핑되어 있어, 이 주소에 데이터를 읽거나 쓰는 것으로 I/O 작업이 이루어집니다.

- **장점**: I/O 작업을 일반적인 메모리 접근과 동일한 방식으로 수행할 수 있어, 코드가 단순해지고, 별도의 I/O 명령어가 필요하지 않습니다.
- **단점**: 메모리 주소 공간을 I/O 장치와 공유하기 때문에, 사용할 수 있는 메모리 주소 공간이 줄어들 수 있습니다.

---

## 저장장치 계층구조

<img src='/assets/img/공부/CS/structure.png' alt='저장장치 계층구조' />

저장장치 게층구조에 대한 이미지 설명

위로 갈수록 속도가 빠른 매체를 사용한다.

연두색: 휘발성 매체 / 빨강색: 비휘발성 매체

- CPU에서 직접 접근할 수 있는 매체를 `Primary`라고 부릅니다.
- CPU가 직접 접근해서 처리 못하는 매체는 `Secondary`라고 부릅니다.

Register와 Main Memory가 속도가 차이가 많이나서 cache Memory가 존재합니다. 다만, 용량이 적기때문에 모든걸 저장하진 못하고 중요내용만 저장합니다.

## 프로그램의 실행 (메모리 load)

### 개요

File System(하드디스크)에 파일형태로 저장이 되어있다. 이 파일을 실행시키면 메모리에 올라가서 프로세스가 된다. 근데 바로 올라가는게 아니라 한단계를 더 거치는데, virtual Memory를 거쳐 올라간다.

### virtual Memory

각 프로그램마다 독자적으로 가지는 공간을 말한다.

<img src='/assets/img/공부/CS/virtualMemory.png' alt='virtual Memory' />

프로그램을 실행시키면 Adress space공간이 생기게 되고, code, stack, data등을 따로 담게된다.

메모리에 Physical Memory에 전부 올리는게 아니라, 사용이 되는 것들만 이동된다. 그리고 사용을 안한다고 판단되면 방출된다.

<aside>
💡 Swap area: 메모리 용량 한계로 메모리 연장공간으로서 사용이된다. 컴퓨터를 종료하게 된다면 File System과 다르게 휘발성이 강하여 데이터가 저장되지않고 사라집니다.

</aside>

## 커널 주소 공간의 내용

<img src='/assets/img/공부/CS/커널.png' alt='커널 주소 공간의 내용' />

운영체제 커널에는 무슨 내용이 있을까요?

### Code

운영체제는 자원을 효율적으로 관리한다. 사용자에게 편리한 서비스를 제공한다. 이와같은 코드들이 커널에 저장되어있다.

- 시스템콜, 인터럽트 처리 코드
- 자원 관리를 위한 코드
- 편리한 서비스 제공을 위한 코드

### Data

운영체제는 CPU나 하드웨어를 직접 관리하고 통제한다. 각 하드웨어마다 자료구조를 하나씩 만들어 관리한다.

### Stack

사용자가 실행시킨 프로그램(Process)들의 커널 스택을 별도로 관리합니다.

## 사용자 프로그램이 사용하는 함수

함수의 종류는 3개로 나눌수 있습니다.

- 사용자 정의 함수 (process function)
  - 자신의 프로그램에서 정의한 함수
- 라이브러리 함수 (process function)
  - 자신의 프로그램에서 정의하지 않고 가져다 쓴 함수
  - 자신의 프로그램의 실행 파일에 포함되어 있습니다.
- 커널 함수 (kernel function)
  - 운영체제 프로그램의 함수
  - 커널 함수의 호출 = 시스템 콜
