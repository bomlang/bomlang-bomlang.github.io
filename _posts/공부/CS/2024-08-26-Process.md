---
layout: post
title: "프로세스"
date: 2024-08-26
categories:
  - study
  - CS
description: >
  이화여대 '반효경'교수님의 Operating Systems강의 중, 'Process 1'강의를 수강하고 학습합니다.
---

# 프로세스의 개념

‘Process is **a program in excution**’

**프로세스(Process)**는 "실행 중인 프로그램(a program in execution)"을 의미합니다. 프로그램 자체는 단순히 코드의 집합일 뿐이지만, 이 코드가 메모리에 로드되어 실행되기 시작하면, 프로세스가 됩니다. 프로세스는 운영체제에서 자원을 할당받아 CPU에서 실행되며, 이 자원은 메모리, CPU 시간, 파일, 입출력 장치 등을 포함합니다.

<img src='/assets/img/공부/CS/process1.png' alt='프로세스의 개념' />

## 프로세스의 문맥

프로세스의 문맥(Context)은 프로그램이 현재 무엇을, 어떻게 실행했는지, 그리고 현재 어떤 시점에 있는지를 나타내는 정보입니다. 문맥은 프로세스의 현재 상태를 나타내는 모든 요소를 포함합니다. 이 문맥은 프로세스가 중단되었다가 다시 시작될 때, 원래의 상태로 돌아가도록 보장하는 데 사용됩니다.

### 문맥의 구성 요소

1. **CPU 수행 관련 하드웨어 문맥**:
   - **Program Counter**: 현재 실행 중인 명령어의 주소를 가리키는 레지스터입니다.
   - **Registers**: CPU가 작업을 수행하는 데 사용하는 각종 레지스터 값입니다.
2. **프로세스의 주소 공간**:
   - **Code**: 실행할 명령어가 저장된 영역입니다.
   - **Data**: 전역 변수와 같은 데이터가 저장된 영역입니다.
   - **Stack**: 함수 호출 시 매개변수, 지역 변수, 리턴 주소 등이 저장되는 영역입니다.
3. **프로세스 관련 커널 자료구조**:
   - **PCB (Process Control Block)**: 프로세스 상태를 저장하고 관리하는 구조체입니다.
   - **Kernel Stack**: 커널 모드에서 사용할 스택 영역입니다.

## 프로세스의 상태 (Process State)

<img src='/assets/img/공부/CS/process2.png' alt='프로세스' />

프로세스 상태도

<img src='/assets/img/공부/CS/process3.png' alt='프로세스' />

suspended가 추가된 프로세스의 상태도

프로세스는 상태(state)를 변경하면서 실행됩니다. 일반적으로 프로세스는 다음과 같은 주요 상태를 가지게 됩니다:

- Running
  - CPU를 잡고 instruction을 수행중인 상태를 말합니다.
- Ready
  - CPU를 기다리는 상태를 말합니다. (‼️ 메모리 등의 다른 모든 조건을 만족하고, 오로지 CPU만을 필요로 하는 상태만을 말합니다.)
- Block (wait, sleep)
  - CPU를 주어도 당장 instruction을 수행할 수 없는 상태를 말합니다.
  - Process자신이 요청한 event(ex: I/O)가 즉시 만족되지 않아 이를 기다리는 상태입니다.
  - ex) 디스크에서 file을 읽어와야 하는 경우
- Suspended (stopped)
  - 외부족인 이유로 프로세스의 수행이 정지된 상태
  - 프로세스는 통째로 디스크에 swap out 됩니다.
  - ex) 사용자가 프로그램을 일시 정지시킨 경우 (break key)
    - 시스템이 여러 이유로 프로세스를 잠시 중단시킵니다. (메모리에 너무 많은 프로세스가 올라와 있을 때)

<aside>
💡

**Blocked: 자신이 요청한 event가 만족되면 Ready**

**Suspended: 외부에서 resume해 주어야 Active**

</aside>

### 🙋‍♂️ 경우에 따라 생기는 상태

- New: 프로세스가 생성중인 상태
- Terminated: 수행(execution)이 끝난 상태 ⇒ 인스트럭션이 다 끝나서 프로세스가 종료되었지만, 종료되고 정리작업이 남아 있습니다. 이 과정을 `Terminated` 라고 부릅니다.

**🤓 예시**) 파일을 읽는 작업을 하는 프로세스 A를 예로 들어보겠습니다. 프로세스 A가 디스크에서 파일을 읽어야 할 때, 읽기 작업이 완료되기 전까지 A는 CPU에서 수행될 수 없습니다. 이때 A는 Blocked 상태가 됩니다. 파일 읽기가 완료되면 A는 다시 Ready 상태로 전환되어 CPU 할당을 기다리게 됩니다.

## PCB (Process Control Block)

<img src='/assets/img/공부/CS/process4.png' alt='PCB' />

**PCB(Process Control Block)**는 운영체제가 각 프로세스를 관리하기 위해 유지하는 자료 구조입니다. PCB는 프로세스의 현재 상태와 관련된 모든 정보를 담고 있으며, 프로세스 간의 문맥 전환 시 중요한 역할을 합니다.

### PCB의 주요 구성 요소

1. **프로세스 관리 정보**:
   - **Process State**: 프로세스의 현재 상태 (Running, Ready 등)입니다.
   - **Process ID (PID)**: 프로세스를 고유하게 식별하기 위한 ID입니다.
   - **Scheduling Information**: 우선순위, 스케줄링 큐에 대한 포인터 등입니다.
2. **CPU 수행 관련 정보**:
   - **Program Counter**: 다음에 실행될 명령어의 주소입니다.
   - **Registers**: 프로세스의 CPU 레지스터 값입니다.
3. **메모리 관리 정보**:
   - **Memory Limits**: 프로세스의 주소 공간에 대한 정보 (코드, 데이터, 스택의 위치)입니다.
4. **파일 관리 정보**:
   - **Open File Descriptors**: 프로세스가 열어 둔 파일에 대한 정보입니다.

## 문맥 교환 (Context Switch)

<img src='/assets/img/공부/CS/process5.png' alt='문맥교환' />

**문맥 교환(Context Switch)**은 CPU를 한 프로세스에서 다른 프로세스로 넘겨주는 과정입니다. 이 과정에서 현재 실행 중인 프로세스의 상태를 PCB에 저장하고, 새롭게 실행될 프로세스의 상태를 PCB에서 읽어와야 합니다.

### 문맥 교환 과정

1. **현재 프로세스의 상태 저장**:
   - 현재 실행 중인 프로세스의 레지스터 값, 프로그램 카운터 등을 PCB에 저장합니다.
2. **새로운 프로세스의 상태 복원**:
   - 새로 실행될 프로세스의 PCB에서 레지스터 값, 프로그램 카운터 등을 복원해 CPU에 설정합니다.

- System call이나 Interrupt 발생시 반드시 context switch가 일어나는 것은 아닙니다.
  - System call: 프로세스 A가 시스템 호출을 하면, 커널 모드에서 실행되다가 다시 사용자 모드로 돌아오고, 같은 프로세스 A가 계속 실행이 됩니다. 프로세스가 바뀌지 않기 때문에 context switch가 아닙니다.
  - Interrupt: 인터럽트가 발생해도 현재 실행 중인 프로세스가 일시적으로 중단되고, 인터럽트 핸들러가 실행되지만, 인터럽트가 처리된 후에는 다시 같은 프로세스가 실행이 됩니다. 역시 프로세스가 바뀌지 않기 때문에 context switch가 아닙니다.

🤓 **예시**

) A라는 프로세스가 실행 중에 타임 슬라이스가 끝나고, B라는 프로세스가 실행될 차례가 왔다고 가정하겠습니다. 이때 A의 모든 실행 상태(문맥)가 PCB에 저장되고, B의 문맥이 복원되어 CPU에서 실행되게 됩니다. 이 과정이 문맥 교환입니다.

# 프로세스를 스케줄링 하기 위한 큐

<img src='/assets/img/공부/CS/process6.png' alt='스케줄링 큐' />

프로세스 스케줄링 큐의 모습

운영체제는 여러 프로세스를 관리하고 실행하기 위해 다양한 큐를 사용합니다. 각 큐는 프로세스의 상태에 따라 프로세스를 분류하고, 스케줄러가 이를 활용해 적절한 프로세스를 실행하게 합니다.

- Job queue
  - 현재 시스템 내에 있는 모든 프로세스의 집합
- Ready queue
  - 메모리에 상주하며, CPU 할당을 기다리는 프로세스를 포함하는 큐입니다.
- Device queues
  - 특정 I/O 장치의 처리를 기다리는 프로세스를 포함하는 큐입니다.

<aside>
💡

**프로세스들은 각 큐들을 오가며 수행됩니다.**

</aside>

## 스케줄러 (Scheduler)

운영체제에는 프로세스를 스케줄링하기 위해 다양한 스케줄러가 존재합니다. 각 스케줄러는 특정 역할을 담당하며, 프로세스의 실행을 관리합니다.

1. **Long-term Scheduler (장기 스케줄러 또는 Job Scheduler)**:
   - 시작 프로세스 중 어떤 것들을 메모리에 올려서 Ready Queue로 보낼지 결정합니다.
   - 메모리와 자원의 할당을 관리하며, 시스템의 다중 프로그래밍 정도를 조절합니다.
2. **Short-term Scheduler (단기 스케줄러 또는 CPU Scheduler)**:
   - Ready Queue에서 어떤 프로세스를 다음에 실행할지 결정합니다.
   - 프로세스에 CPU를 할당하는 문제를 다루며, 매우 빠르게 동작해야 합니다.
3. **Medium-term Scheduler (중기 스케줄러 또는 Swapper)**:
   - 여유 공간을 마련하기 위해 프로세스를 메모리에서 디스크로 스왑 아웃(swap out)하거나 스왑 인(swap in) 시킵니다.
   - 시스템의 다중 프로그래밍 정도를 조절하는 역할도 합니다.
